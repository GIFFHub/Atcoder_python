'''
・夏休みN日間の行動は３通り
・二日連続同じ行動は取れない
・各行動の幸福度は毎日異なる
・最大値を求める
・動的計画法
　・前日までの最大幸福を動的計画法で計算していく
　・二日連続で同じ行動は取れないことから、

'''

if __name__ == '__main__':

    N = int(input())

    A, B, C = [], [], []
    for _ in range(N):
        a, b, c = map(int, input().split())
        A.append(a) # 海で泳ぐ
        B.append(b) # 山で虫取り
        C.append(c) # 家で宿題

    dp = [[0 for _ in range(3)] for _ in range(N)]

    dp[0][0] = A[0]
    dp[0][1] = B[0]
    dp[0][2] = C[0]

    '''
    [[A[0], B[0], C[0]] # 初日の幸福度
     [①, ②, ③] 
     [①, ②, ③] 
     [①, ②, ③] 


    ①：前日にAを選択（当日B or Cを選択する）場合の最大幸福度
    ②：前日にBを選択（当日A or Cを選択する）場合の最大幸福度
    ③：前日にCを選択（当日A or Bを選択する）場合の最大幸福度
    
    '''

    for i in range(1, N): # i+1日目について
        # 前日にAを選択した場合（当日B or Cを選択した場合）の最大幸福度
        # dp[i-1][1] + A[i] = [前々日にBを選んだ場合の最大幸福値 + 前日のA]
        # dp[i-1][2] + A[i] = [前々日にCを選んだ場合の最大幸福値 + 前日のA]

        dp[i][0] = max(dp[i - 1][1] + A[i], dp[i - 1][2] + A[i])

        # 前日にBを選択した場合（当日A or Cを選択した場合）の最大幸福度
        dp[i][1] = max(dp[i - 1][2] + B[i], dp[i - 1][0] + B[i])

        # 前日にCを選択した場合（当日A or Bを選択した場合）の最大幸福度
        dp[i][2] = max(dp[i - 1][0] + C[i], dp[i - 1][1] + C[i])

    print(max(dp[-1]))


